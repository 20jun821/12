<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테트리스 게임</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas {
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="300" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scale = 30; // 블록 크기
        const rows = canvas.height / scale;
        const cols = canvas.width / scale;
        const tetrominoes = [
            [[1, 1, 1, 1]], // I
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1], [1, 1]], // O
            [[0, 1, 1], [1, 1, 0]], // S
            [[1, 1, 0], [0, 1, 1]], // Z
            [[1, 1, 1], [1, 0, 0]], // L
            [[1, 1, 1], [0, 0, 1]]  // J
        ];
        const colors = ['cyan', 'purple', 'yellow', 'green', 'red', 'orange', 'blue'];
        let board = Array.from({ length: rows }, () => Array(cols).fill(0));
        let currentTetromino, currentColor, currentX, currentY;
        let lastTime = 0;
        const dropInterval = 1000; // 밀리초 단위, 조각이 내려오는 간격

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (board[row][col]) {
                        ctx.fillStyle = colors[board[row][col] - 1];
                        ctx.fillRect(col * scale, row * scale, scale, scale);
                        ctx.strokeRect(col * scale, row * scale, scale, scale);
                    }
                }
            }
        }

        function drawTetromino() {
            ctx.fillStyle = currentColor;
            for (let row = 0; row < currentTetromino.length; row++) {
                for (let col = 0; col < currentTetromino[row].length; col++) {
                    if (currentTetromino[row][col]) {
                        ctx.fillRect((currentX + col) * scale, (currentY + row) * scale, scale, scale);
                        ctx.strokeRect((currentX + col) * scale, (currentY + row) * scale, scale, scale);
                    }
                }
            }
        }

        function drawPreview() {
            let previewX = currentX;
            let previewY = currentY;

            // Move the preview down until it hits the bottom or another block
            while (!isCollision(0, 1, currentTetromino)) {
                previewY++;
            }

            // Draw preview
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; // Semi-transparent color for preview
            for (let row = 0; row < currentTetromino.length; row++) {
                for (let col = 0; col < currentTetromino[row].length; col++) {
                    if (currentTetromino[row][col]) {
                        ctx.fillRect((previewX + col) * scale, (previewY + row) * scale, scale, scale);
                        ctx.strokeRect((previewX + col) * scale, (previewY + row) * scale, scale, scale);
                    }
                }
            }
        }

        function draw() {
            drawBoard();
            drawTetromino();
            drawPreview();
        }

        function isCollision(offsetX, offsetY, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] && (
                        board[row + currentY + offsetY] === undefined ||
                        board[row + currentY + offsetY][col + currentX + offsetX] === undefined ||
                        board[row + currentY + offsetY][col + currentX + offsetX]
                    )) {
                        return true;
                    }
                }
            }
            return false;
        }

        function mergeTetromino() {
            for (let row = 0; row < currentTetromino.length; row++) {
                for (let col = 0; col < currentTetromino[row].length; col++) {
                    if (currentTetromino[row][col]) {
                        board[row + currentY][col + currentX] = colors.indexOf(currentColor) + 1;
                    }
                }
            }
        }

        function clearLines() {
            for (let row = rows - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                    board.splice(row, 1);
                    board.unshift(Array(cols).fill(0));
                }
            }
        }

        function rotate() {
            const temp = currentTetromino;
            currentTetromino = currentTetromino[0].map((_, i) => currentTetromino.map(row => row[i])).reverse();
            if (isCollision(0, 0, currentTetromino)) {
                currentTetromino = temp;
            }
        }

        function drop() {
            if (!isCollision(0, 1, currentTetromino)) {
                currentY++;
            } else {
                mergeTetromino();
                clearLines();
                newTetromino();
            }
        }

        function move(dir) {
            if (!isCollision(dir, 0, currentTetromino)) {
                currentX += dir;
                // Ensure the preview moves with the current tetromino
                draw();
            }
        }

        function newTetromino() {
            const index = Math.floor(Math.random() * tetrominoes.length);
            currentTetromino = tetrominoes[index];
            currentColor = colors[index];
            currentX = Math.floor(cols / 2) - Math.floor(currentTetromino[0].length / 2);
            currentY = 0;
            if (isCollision(0, 0, currentTetromino)) {
                alert('Game Over');
                window.location.reload(); // 게임 오버 시 페이지 새로 고침
            }
        }

        function keyDown(e) {
            switch (e.key) {
                case 'ArrowLeft':
                    move(-1);
                    break;
                case 'ArrowRight':
                    move(1);
                    break;
                case 'ArrowDown':
                    drop();
                    break;
                case 'ArrowUp':
                    rotate();
                    break;
            }
            draw();
        }

        function gameLoop(timestamp) {
            if (timestamp - lastTime > dropInterval) {
                lastTime = timestamp;
                drop();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            board = Array.from({ length: rows }, () => Array(cols).fill(0));
            newTetromino();
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', keyDown);
        startGame();
    </script>
</body>
</html>
